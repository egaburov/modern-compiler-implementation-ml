# Tiger Programming Language

This is a compiler for the Tiger programming language, created from the
projects in Modern Compiler Implementation in ML, by Appel.


# Lexer

The lexer is specified in `tiger.lex` and generated by `ml-lex`.

## Strings

Strings are enclosed in double-quotes(`"My String"`). Multi-line strings are
allowed using the a backslash immediately before a newline and another before
any text:
```
"My multi-line \
    \string."
```
Any white-space between the backslashes is removed.

When a backlash is encountered, the STRING state transitions to the
STRING_ESCAPE state, where any escape sequences are handled. The STRING_ESCAPE
state may transition to the STRING_CONTROL state for handling control
characters, or the STRING_LONG_ESCAPE for handling multi-line strings. After an
escape sequence, the lexer transitions back to the STRING state.

## Comments

Multi-line, nested comments are allowed. This is implemented by counting the
comment depth. Opening a comment increases the depth by one, closing a comment
decreases the depth by one. If the lexer reaches the end of the file and the
comment depth is not zero, then there is an unclosed comment in the file. If
this occurs, an error is reported.

## Error Handling

Error handling is minimal. The line and column of the error are shown along with
an error message. Errors do not halt execution of the parser. Non-whitespace
characters between the backslashes of multi-line strings are ignored & reported.
Unclosed strings are reported as well.

## End of File

When the end of the file is reached, the lexer ensures all comments have been
closed before returning the EOF token.


# Parser

The grammer for the parser is specified in `tiger.grm` and generated by
`ml-yacc`. The grammar follows the general outline of the Tiger reference.

A special exception is made for lvalues, as parsing array lvalues caused a
shift/reduce conflict with the parsing of array instantiation. Instead of
directly parsing all lvalues in an expression, we parse an ID as an expression
and lvalues that are not IDs as another expression. Then we reference the
full class of lvalues from the parse.
